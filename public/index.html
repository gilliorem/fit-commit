<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>42 Fit Commit Leaderboard</title>
    <style>
      :root {
        color-scheme: dark;
        --bg-primary: #040b16;
        --bg-elevated: rgba(11, 22, 40, 0.72);
        --bg-card: rgba(9, 19, 32, 0.88);
        --text-primary: #eef6ff;
        --text-secondary: #8ba1c4;
        --accent: #22d4d9;
        --accent-soft: rgba(34, 212, 217, 0.2);
        --accent-strong: rgba(34, 212, 217, 0.55);
        --border: rgba(55, 95, 124, 0.45);
        --shadow: 0 24px 60px rgba(4, 8, 20, 0.55);
      }

      * {
        box-sizing: border-box;
      }

      body {
        margin: 0;
        min-height: 100vh;
        background:
          radial-gradient(circle at 20% -10%, rgba(34, 212, 217, 0.18), transparent 40%),
          radial-gradient(circle at 85% 0%, rgba(0, 132, 255, 0.14), transparent 46%),
          var(--bg-primary);
        color: var(--text-primary);
        font-family: 'Rajdhani', 'Segoe UI', 'Roboto', sans-serif;
        display: flex;
        justify-content: center;
        padding: 3rem 1.5rem 4rem;
      }

      .app-shell {
        width: min(1200px, 100%);
        display: flex;
        flex-direction: column;
        gap: 1.75rem;
      }

      .app-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        background: var(--bg-elevated);
        border: 1px solid var(--border);
        border-radius: 18px;
        padding: 1.5rem 1.75rem;
        box-shadow: var(--shadow);
        backdrop-filter: blur(18px);
      }

      .brand {
        display: flex;
        align-items: center;
        gap: 1rem;
      }

      .brand-mark {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        width: 52px;
        height: 52px;
        border-radius: 14px;
        font-weight: 700;
        font-size: 1.5rem;
        letter-spacing: 0.08em;
        color: var(--accent);
        border: 1px solid var(--accent-strong);
        background: var(--accent-soft);
        box-shadow: 0 16px 40px rgba(34, 212, 217, 0.25);
      }

      h1 {
        margin: 0;
        font-size: 1.85rem;
        letter-spacing: 0.12em;
        text-transform: uppercase;
      }

      .status-chip {
        margin-left: auto;
        font-size: 0.85rem;
        letter-spacing: 0.12em;
        text-transform: uppercase;
        padding: 0.35rem 0.9rem;
        border-radius: 999px;
        border: 1px solid var(--accent-strong);
        background: var(--accent-soft);
        color: var(--accent);
        transition: opacity 0.2s ease;
      }

      .status-chip:empty {
        display: none;
      }

      .status-chip--error {
        color: #ff7a94;
        border-color: rgba(255, 122, 148, 0.45);
        background: rgba(255, 122, 148, 0.18);
      }

      .event-window {
        background: var(--bg-elevated);
        border: 1px solid var(--border);
        border-radius: 16px;
        padding: 1.25rem 1.75rem;
        box-shadow: var(--shadow);
        text-transform: uppercase;
        letter-spacing: 0.18em;
        font-size: 0.8rem;
        color: var(--text-secondary);
        backdrop-filter: blur(16px);
      }

      .event-window:empty {
        display: none;
      }

      .panel {
        background: var(--bg-card);
        border: 1px solid var(--border);
        border-radius: 20px;
        padding: 1.75rem;
        box-shadow: var(--shadow);
        backdrop-filter: blur(18px);
      }

      .panel h2 {
        margin: 0 0 1.25rem;
        font-size: 1rem;
        text-transform: uppercase;
        letter-spacing: 0.16em;
        color: var(--text-secondary);
      }

      .top-teams {
        display: flex;
        flex-wrap: wrap;
        justify-content: center;
        gap: 2rem;
        margin-bottom: 2rem;
      }

      .top-team-node {
        --circle-size: 180px;
        --progress: 0;
        position: relative;
        width: var(--circle-size);
        height: var(--circle-size);
        border-radius: 50%;
        background:
          radial-gradient(circle at 30% 30%, rgba(34, 212, 217, 0.5), transparent 70%),
          rgba(7, 18, 32, 0.9);
        box-shadow: 0 24px 45px rgba(0, 0, 0, 0.45);
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        text-align: center;
        padding: 1.5rem 1rem;
        backdrop-filter: blur(18px);
        z-index: 0;
      }

      .top-team-node::before {
        content: '';
        position: absolute;
        inset: 0;
        border-radius: 50%;
        border: 2px solid rgba(34, 212, 217, 0.25);
        z-index: -2;
      }

      .top-team-node::after {
        content: '';
        position: absolute;
        inset: -12px;
        border-radius: 50%;
        background: conic-gradient(
          rgba(34, 212, 217, 0.9) calc(var(--progress) * 360deg),
          rgba(34, 212, 217, 0.1) 0deg
        );
        -webkit-mask: radial-gradient(circle, transparent calc(50% - 12px), black calc(50% - 11px));
        mask: radial-gradient(circle, transparent calc(50% - 12px), black calc(50% - 11px));
        z-index: -1;
      }

      .top-team-rank {
        font-size: 0.85rem;
        letter-spacing: 0.22em;
        text-transform: uppercase;
        color: var(--text-secondary);
        margin-bottom: 0.35rem;
      }

      .top-team-name {
        font-size: 1.15rem;
        font-weight: 600;
        letter-spacing: 0.12em;
        text-transform: uppercase;
        color: var(--accent);
        margin-bottom: 0.5rem;
      }

      .top-team-distance {
        font-size: 0.9rem;
        color: var(--text-primary);
      }

      .leaderboard-table {
        width: 100%;
        border-collapse: collapse;
      }

      .leaderboard-table th,
      .leaderboard-table td {
        padding: 0.75rem 0.9rem;
        text-align: left;
      }

      .leaderboard-table th {
        font-size: 0.75rem;
        font-weight: 600;
        letter-spacing: 0.18em;
        text-transform: uppercase;
        border-bottom: 1px solid rgba(255, 255, 255, 0.04);
        color: var(--text-secondary);
      }

      .leaderboard-table td {
        font-size: 0.95rem;
        color: var(--text-primary);
        border-bottom: 1px solid rgba(255, 255, 255, 0.03);
      }

      .leaderboard-table .highlight-team td {
        color: var(--accent);
        font-weight: 600;
      }

      .leaderboard-table tbody tr {
        background: rgba(15, 32, 49, 0.35);
        transition: background 0.2s ease;
      }

      .leaderboard-table tbody tr:nth-child(odd) {
        background: rgba(15, 32, 49, 0.22);
      }

      .leaderboard-table tbody tr:hover {
        background: rgba(34, 212, 217, 0.14);
      }

      .teams-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
        gap: 1.5rem;
      }

      .team-card {
        background:
          radial-gradient(circle at top, rgba(34, 212, 217, 0.18), transparent 60%),
          rgba(10, 21, 35, 0.9);
        border: 1px solid var(--border);
        border-radius: 18px;
        padding: 1.4rem;
        box-shadow: var(--shadow);
        backdrop-filter: blur(16px);
      }

      .team-card h3 {
        margin: 0 0 1rem;
        font-size: 0.95rem;
        letter-spacing: 0.18em;
        text-transform: uppercase;
        color: var(--accent);
      }

      .team-card table {
        width: 100%;
      }

      .placeholder {
        opacity: 0.6;
        font-style: italic;
        color: var(--text-secondary);
      }

      @media (max-width: 720px) {
        body {
          padding: 2rem 1rem 3rem;
        }

        .app-header {
          flex-direction: column;
          align-items: flex-start;
          gap: 1rem;
        }

        .status-chip {
          margin-left: 0;
        }

        .panel {
          padding: 1.5rem;
        }
      }
    </style>
  </head>
  <body>
    <div class="app-shell">
      <header class="app-header">
        <div class="brand">
          <span class="brand-mark">42</span>
          <h1>Fit Commit Leaderboard</h1>
        </div>
        <div id="status" class="status-chip">Loading activitiesâ€¦</div>
      </header>

      <section id="event-window" class="event-window"></section>

      <section id="global-leaderboard" class="panel">
        <h2>Team Overview</h2>
        <div id="top-teams" class="top-teams"></div>
        <div id="global-team-list"></div>
      </section>

      <section class="panel">
        <h2>Team Leaderboards</h2>
        <div id="teams-container" class="teams-grid"></div>
      </section>
    </div>

    <script>
      function formatEventDate(isoString) {
        if (!isoString) {
          return null;
        }
        const date = new Date(isoString);
        if (Number.isNaN(date.getTime())) {
          return null;
        }

        return new Intl.DateTimeFormat(undefined, {
          month: 'short',
          day: 'numeric',
          year: 'numeric'
        }).format(date);
      }

      function buildEventWindowLabel(event) {
        if (!event || (!event.start && !event.end)) {
          return '';
        }

        const start = formatEventDate(event.start);
        const end = formatEventDate(event.end);

        if (start && end) {
          return `Event window: ${start} - ${end}`;
        }

        if (start) {
          return `Activities from ${start}`;
        }

        if (end) {
          return `Activities up to ${end}`;
        }

        return '';
      }

      function stripDiacritics(value) {
        const str = String(value || '');
        if (typeof str.normalize === 'function') {
          return str.normalize('NFD').replace(/[\u0300-\u036f]/g, '');
        }
        return str;
      }

      function normaliseName(value) {
        return stripDiacritics(value).trim().toLowerCase();
      }

      function tokenize(value) {
        const normalised = normaliseName(value);

        let cleaned;
        try {
          cleaned = normalised.replace(/[^\p{Letter}\p{Number}]+/gu, ' ');
        } catch (error) {
          cleaned = normalised.replace(/[^a-z0-9]+/g, ' ');
        }

        return cleaned
          .split(' ')
          .map((token) => token.trim())
          .filter(Boolean);
      }

      const TRACKED_MEMBER_NAMES = [
        'JJ Su',
        'Chris Wan',
        'Neoprana Soemardjan',
        'Abel L',
        'Li Qian Teng',
        'Louisa N',
        'Timberley Ng',
        'Sebby Wong',
        'F Lim'
      ];

      function buildAthleteIndex(athletes) {
        const byFull = new Map();
        const byFirst = new Map();
        const byLast = new Map();
        const byToken = new Map();

        const addToMap = (map, key, candidate) => {
          if (!key) {
            return;
          }
          if (!map.has(key)) {
            map.set(key, []);
          }
          map.get(key).push(candidate);
        };

        const uniqueTokens = (values) => {
          const seen = new Set();
          values.forEach((token) => {
            if (token) {
              seen.add(token);
            }
          });
          return Array.from(seen);
        };

        const candidates = athletes.map((athlete) => {
          const nameTokens = tokenize(athlete.name || '');
          const firstTokens = tokenize(athlete.firstName || '');
          const lastTokens = tokenize(athlete.lastName || '');
          const tokens = uniqueTokens([...nameTokens, ...firstTokens, ...lastTokens]);

          return {
            athlete,
            normalisedFull: normaliseName(athlete.name || `${athlete.firstName || ''} ${athlete.lastName || ''}`),
            firstToken: firstTokens[0] || '',
            lastToken: lastTokens[lastTokens.length - 1] || '',
            tokens
          };
        });

        candidates.forEach((candidate) => {
          addToMap(byFull, candidate.normalisedFull, candidate);
          addToMap(byFirst, candidate.firstToken, candidate);
          addToMap(byLast, candidate.lastToken, candidate);
          candidate.tokens.forEach((token) => addToMap(byToken, token, candidate));
        });

        return { byFull, byFirst, byLast, byToken };
      }

      function updateStatus(element, message, tone = 'default') {
        if (!element) {
          return;
        }

        element.classList.toggle('status-chip--error', tone === 'error');
        element.textContent = message || '';
      }

      function findUniqueCandidate(candidates, usedIds) {
        if (!Array.isArray(candidates)) {
          return null;
        }

        const available = candidates.filter((candidate) => !usedIds.has(candidate.athlete.athleteId));
        return available.length === 1 ? available[0] : null;
      }

      function intersectCandidateLists(lists, usedIds) {
        const filtered = lists
          .filter((list) => Array.isArray(list) && list.length)
          .map((list) => list.filter((candidate) => !usedIds.has(candidate.athlete.athleteId)));

        if (filtered.length === 0) {
          return [];
        }

        return filtered.reduce((acc, list) =>
          acc.filter((candidate) => list.some((item) => item.athlete.athleteId === candidate.athlete.athleteId))
        );
      }

      function tokenSimilarity(memberToken, candidateToken) {
        if (memberToken === candidateToken) {
          return 2; // exact match
        }

        if (memberToken.length >= 3 && candidateToken.length >= 3) {
          if (candidateToken.startsWith(memberToken) || memberToken.startsWith(candidateToken)) {
            return 1; // prefix / abbreviation match
          }
          const memberPrefix = memberToken.slice(0, 3);
          const candidatePrefix = candidateToken.slice(0, 3);
          if (memberPrefix === candidatePrefix) {
            return 1; // shared leading syllable
          }
        }

        return 0;
      }

      function scoreCandidate(candidate, memberTokens) {
        if (!Array.isArray(memberTokens) || memberTokens.length === 0) {
          return { score: 0, exactMatches: 0, prefixMatches: 0, coversAll: false };
        }

        let exactMatches = 0;
        let prefixMatches = 0;

        memberTokens.forEach((token) => {
          const bestMatch = candidate.tokens.reduce((best, candidateToken) => {
            const score = tokenSimilarity(token, candidateToken);
            return score > best ? score : best;
          }, 0);

          if (bestMatch === 2) {
            exactMatches += 1;
          } else if (bestMatch === 1) {
            prefixMatches += 1;
          }
        });

        const matchedTokens = exactMatches + prefixMatches;
        const coversAll = matchedTokens === memberTokens.length && memberTokens.length > 0;
        const score = exactMatches * 3 + prefixMatches + (coversAll ? 1 : 0);
        return { score, exactMatches, prefixMatches, coversAll };
      }

      function chooseBestCandidate(candidates, memberTokens) {
        const scored = candidates
          .map((candidate) => ({ candidate, ...scoreCandidate(candidate, memberTokens) }))
          .filter((entry) => entry.score > 0);

        if (scored.length === 0) {
          return null;
        }

        const coverAll = scored.filter((entry) => entry.coversAll);
        const pool = coverAll.length ? coverAll : scored;
        const bestScore = Math.max(...pool.map((entry) => entry.score));
        const top = pool.filter((entry) => entry.score === bestScore);

        if (top.length === 1) {
          return top[0].candidate;
        }

        // prefer the one with more exact matches when there's a tie
        const bestExact = Math.max(...top.map((entry) => entry.exactMatches));
        const exactWinners = top.filter((entry) => entry.exactMatches === bestExact);

        if (exactWinners.length === 1) {
          return exactWinners[0].candidate;
        }

        return exactWinners[0]?.candidate || top[0]?.candidate || null;
      }

      function scoreTokens(candidateTokens, targetTokens) {
        return targetTokens.reduce((total, token) => {
          const tokenScore = candidateTokens.reduce(
            (best, candidateToken) => Math.max(best, tokenSimilarity(token, candidateToken)),
            0
          );
          return total + tokenScore;
        }, 0);
      }

      function findTrackedAthlete(trackedTokens, athletes) {
        if (!Array.isArray(trackedTokens) || trackedTokens.length === 0) {
          return null;
        }

        const scored = athletes
          .map((athlete) => {
            const tokens = tokenize(athlete.name || `${athlete.firstName || ''} ${athlete.lastName || ''}`);
            return { athlete, score: scoreTokens(tokens, trackedTokens) };
          })
          .filter((entry) => entry.score > 0);

        if (scored.length === 0) {
          return null;
        }

        return scored.reduce((best, current) => (current.score > best.score ? current : best)).athlete;
      }

      function reportTrackedMembers(teamsWithStats, athletes) {
        if (!Array.isArray(teamsWithStats) || !Array.isArray(athletes)) {
          return;
        }

        const trackedTokensMap = new Map(
          TRACKED_MEMBER_NAMES.map((name) => [normaliseName(name), tokenize(name)])
        );

        const summaries = TRACKED_MEMBER_NAMES.map((rawName) => {
          const key = normaliseName(rawName);
          const tokens = trackedTokensMap.get(key) || [];

          const membershipHits = [];
          teamsWithStats.forEach((team) => {
            team.members.forEach((member) => {
              if (normaliseName(member.memberName) === key) {
                membershipHits.push({
                  team: team.name,
                  matched: Boolean(member.athlete),
                  athleteName: member.athlete?.name || null
                });
              }
            });
          });

          const matchedEntry = membershipHits.find((entry) => entry.matched);
          const fallbackAthlete = matchedEntry ? null : findTrackedAthlete(tokens, athletes);

          return {
            name: rawName,
            presentInTeams: membershipHits.length > 0,
            matchedTeam: matchedEntry ? matchedEntry.team : null,
            matchedAthlete: matchedEntry?.athleteName || fallbackAthlete?.name || null
          };
        });

        if (summaries.some((entry) => entry.presentInTeams || entry.matchedAthlete)) {
          console.groupCollapsed('Tracked member cross-check');
          summaries.forEach((entry) => {
            const message = entry.presentInTeams
              ? `in ${entry.matchedTeam || 'team list'}, matched=${Boolean(entry.matchedAthlete)}`
              : entry.matchedAthlete
                ? `not in CSV, but activity matches ${entry.matchedAthlete}`
                : 'not found in teams or activities';
            console.log(`%c${entry.name}`, 'color: #22d4d9;', message);
          });
          console.groupEnd();
        }
      }

      function gatherTokenCandidates(tokens, index, usedIds) {
        const set = new Map();

        tokens.forEach((token) => {
          const candidates = index.byToken.get(token);
          if (!Array.isArray(candidates)) {
            return;
          }

          candidates.forEach((candidate) => {
            const athleteId = candidate.athlete.athleteId;
            if (usedIds.has(athleteId)) {
              return;
            }
            if (!set.has(athleteId)) {
              set.set(athleteId, candidate);
            }
          });
        });

        return Array.from(set.values());
      }

      function matchAthlete(memberName, index, usedIds) {
        const normalisedFull = normaliseName(memberName);
        const tokens = tokenize(memberName);
        const firstToken = tokens[0] || '';
        const lastToken = tokens.length > 1 ? tokens[tokens.length - 1] : '';

        const fullMatch = findUniqueCandidate(index.byFull.get(normalisedFull), usedIds);
        if (fullMatch) {
          return fullMatch.athlete;
        }

        const intersection = intersectCandidateLists(
          [
            firstToken ? index.byFirst.get(firstToken) : null,
            lastToken ? index.byLast.get(lastToken) : null
          ],
          usedIds
        );

        if (intersection.length === 1) {
          return intersection[0].athlete;
        }

        const tokenCandidates = gatherTokenCandidates(tokens, index, usedIds);
        const bestTokenCandidate = chooseBestCandidate(tokenCandidates, tokens);
        if (bestTokenCandidate) {
          return bestTokenCandidate.athlete;
        }

        const firstMatch = findUniqueCandidate(index.byFirst.get(firstToken), usedIds);
        if (firstMatch) {
          return firstMatch.athlete;
        }

        if (tokens.length >= 2) {
          const initialToken = tokens[tokens.length - 1];
          if (initialToken.length === 1 && firstToken) {
            const candidates = (index.byFirst.get(firstToken) || []).filter(
              (candidate) => !usedIds.has(candidate.athlete.athleteId)
            );
            const initialMatches = candidates.filter((candidate) => candidate.lastToken.startsWith(initialToken));
            if (initialMatches.length === 1) {
              return initialMatches[0].athlete;
            }
          }
        }

        if (lastToken) {
          const lastMatch = findUniqueCandidate(index.byLast.get(lastToken), usedIds);
          if (lastMatch) {
            return lastMatch.athlete;
          }
        }

        return null;
      }

      function buildTeamStats(teams, athletes) {
        const index = buildAthleteIndex(athletes);
        const usedIds = new Set();

        return teams.map((team) => {
          const members = team.members.map((memberName) => {
            const athlete = matchAthlete(memberName, index, usedIds);

            if (athlete) {
              usedIds.add(athlete.athleteId);
            }

            return {
              memberName,
              athlete,
              displayName: athlete ? athlete.name : `${memberName} (NR)`
            };
          });

          const totalDistance = members.reduce((sum, member) => {
            if (!member.athlete) {
              return sum;
            }
            return sum + (member.athlete.distance_km || 0);
          }, 0);

          return {
            name: team.name,
            members,
            totalDistance
          };
        });
      }

      function renderTopTeams(container, teams) {
        if (!container) {
          return;
        }

        if (teams.length === 0) {
          container.innerHTML = '<p class="placeholder">No team activity yet.</p>';
          return;
        }

        container.innerHTML = teams
          .map((team, index) => {
            const ratio = Math.min(team.totalDistance / 420, 1);
            const size = Math.round(140 + ratio * 100);

            return `
              <div class="top-team-node" style="--circle-size:${size}px; --progress:${ratio}">
                <div class="top-team-rank">#${index + 1}</div>
                <div class="top-team-name">${team.name}</div>
                <div class="top-team-distance">${team.totalDistance.toFixed(1)} km</div>
              </div>
            `;
          })
          .join('');
      }

      function renderTeamDistanceList(container, teams, highlightedNames) {
        if (!container) {
          return;
        }

        if (teams.length === 0) {
          container.innerHTML = '';
          return;
        }

        const highlight = new Set(highlightedNames);

        container.innerHTML = `
          <table class="leaderboard-table">
            <thead>
              <tr>
                <th>Team</th>
                <th>Total Distance (km)</th>
              </tr>
            </thead>
            <tbody>
              ${teams
                .map((team) => {
                  const isHighlight = highlight.has(team.name);
                  const label = isHighlight ? `${team.name} â€¢` : team.name;
                  return `
                    <tr${isHighlight ? ' class="highlight-team"' : ''}>
                      <td>${label}</td>
                      <td>${team.totalDistance.toFixed(2)}</td>
                    </tr>
                  `;
                })
                .join('')}
            </tbody>
          </table>
        `;
      }

      function renderTeams(container, teams) {
        container.innerHTML = teams
          .map((team) => `
            <article class="team-card">
              <h3>${team.name}</h3>
              <table class="leaderboard-table">
                <thead>
                  <tr>
                    <th>Name</th>
                    <th>Distance (km)</th>
                    <th>Avg Speed (km/h)</th>
                  </tr>
                </thead>
                <tbody>
                  ${team.members
                    .map((member) => {
                      if (!member.athlete) {
                        return `
                          <tr>
                            <td class="placeholder">${member.displayName}</td>
                            <td class="placeholder">--</td>
                            <td class="placeholder">--</td>
                          </tr>
                        `;
                      }

                      return `
                        <tr>
                          <td>${member.displayName}</td>
                          <td>${member.athlete.distance_km.toFixed(2)}</td>
                          <td>${member.athlete.avg_speed_kmh.toFixed(2)}</td>
                        </tr>
                      `;
                    })
                    .join('')}
                </tbody>
              </table>
            </article>
          `)
          .join('');
      }

      async function fetchJson(url) {
        const response = await fetch(url);
        if (!response.ok) {
          throw new Error(`Request failed with status ${response.status}`);
        }
        return response.json();
      }

      async function loadLeaderboards() {
        const status = document.getElementById('status');
        const eventWindow = document.getElementById('event-window');
        const globalContainer = document.getElementById('global-leaderboard');
        const topTeamsContainer = document.getElementById('top-teams');
        const globalTeamList = document.getElementById('global-team-list');
        const teamsContainer = document.getElementById('teams-container');

        updateStatus(status, 'Loading activitiesâ€¦');
        eventWindow.textContent = '';
        try {
          const [activitiesPayload, teamsPayload] = await Promise.all([
            fetchJson('/api/club/activities'),
            fetchJson('/api/teams')
          ]);

          const athletes = activitiesPayload.activities || [];
          const teams = teamsPayload.teams || [];

          eventWindow.textContent = buildEventWindowLabel(activitiesPayload.event);

          if (teams.length === 0) {
            updateStatus(status, 'No teams configured yet.');
            globalContainer.innerHTML = '';
            teamsContainer.innerHTML = '';
            return;
          }

          const teamsWithStats = buildTeamStats(teams, athletes);

          if (athletes.length === 0) {
            updateStatus(status, 'No walk or run activities found.');
          } else {
            updateStatus(status, '');
          }

          const sortedByDistance = [...teamsWithStats].sort((a, b) => b.totalDistance - a.totalDistance);
          const topTeams = sortedByDistance.slice(0, 3);
          const topTeamNames = topTeams.map((team) => team.name);
          const remainingChronological = teamsWithStats.filter((team) => !topTeamNames.includes(team.name));

          renderTopTeams(topTeamsContainer, topTeams);
          renderTeamDistanceList(globalTeamList, [...topTeams, ...remainingChronological], topTeamNames);
          renderTeams(teamsContainer, teamsWithStats);
          reportTrackedMembers(teamsWithStats, athletes);
        } catch (error) {
          console.error(error);
          updateStatus(status, 'Could not load leaderboard data. Please try again later.', 'error');
          eventWindow.textContent = '';
        }
      }

      loadLeaderboards();
    </script>
  </body>
</html>
