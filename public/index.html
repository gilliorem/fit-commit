<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>42 Fit Commit Leaderboard</title>
    <style>
      body {
        font-family: Roboto, sans-serif;
        margin: 2rem;
        background: #f5f5f5;
      }
      h1 {
        margin-bottom: 1rem;
      }
      #status {
        margin-bottom: 1rem;
        color: #555;
      }
      #event-window {
        margin-bottom: 1.5rem;
        color: #333;
      }
      .leaderboard-table {
        width: 100%;
        border-collapse: collapse;
        background: #fff;
      }
      .leaderboard-table th,
      .leaderboard-table td {
        border: 1px solid #ddd;
        padding: 0.5rem 0.75rem;
        text-align: left;
      }
      .leaderboard-table th {
        background: #f0f0f0;
      }
      .leaderboard-table tbody tr:nth-child(even) {
        background: #fafafa;
      }
      .leaderboard-section {
        margin-bottom: 2rem;
      }
      .leaderboard-section h2 {
        margin-bottom: 0.75rem;
      }
      .teams-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(260px, 1fr));
        gap: 1.5rem;
      }
      .team-card {
        background: #fff;
        border: 1px solid #ddd;
        border-radius: 6px;
        padding: 1rem;
        box-shadow: 0 1px 3px rgba(0, 0, 0, 0.08);
      }
      .team-card h3 {
        margin-top: 0;
        margin-bottom: 0.75rem;
        font-size: 1.1rem;
      }
      .team-card table {
        width: 100%;
      }
    </style>
  </head>
  <body>
    <h1>42 Fit Commit Leaderboard</h1>
    <div id="status">Loading activitiesâ€¦</div>
    <div id="event-window"></div>
    <section id="global-leaderboard" class="leaderboard-section"></section>
    <section class="leaderboard-section">
      <h2>Team Leaderboards</h2>
      <div id="teams-container" class="teams-grid"></div>
    </section>

    <script>
      function formatEventDate(isoString) {
        if (!isoString) {
          return null;
        }
        const date = new Date(isoString);
        if (Number.isNaN(date.getTime())) {
          return null;
        }

        return new Intl.DateTimeFormat(undefined, {
          month: 'short',
          day: 'numeric',
          year: 'numeric'
        }).format(date);
      }

      function buildEventWindowLabel(event) {
        if (!event || (!event.start && !event.end)) {
          return '';
        }

        const start = formatEventDate(event.start);
        const end = formatEventDate(event.end);

        if (start && end) {
          return `Event window: ${start} - ${end}`;
        }

        if (start) {
          return `Activities from ${start}`;
        }

        if (end) {
          return `Activities up to ${end}`;
        }

        return '';
      }

      function stripDiacritics(value) {
        const str = String(value || '');
        if (typeof str.normalize === 'function') {
          return str.normalize('NFD').replace(/[\u0300-\u036f]/g, '');
        }
        return str;
      }

      function normaliseName(value) {
        return stripDiacritics(value).trim().toLowerCase();
      }

      function tokenize(value) {
        const normalised = normaliseName(value);

        let cleaned;
        try {
          cleaned = normalised.replace(/[^\p{Letter}\p{Number}]+/gu, ' ');
        } catch (error) {
          cleaned = normalised.replace(/[^a-z0-9]+/g, ' ');
        }

        return cleaned
          .split(' ')
          .map((token) => token.trim())
          .filter(Boolean);
      }

      function buildAthleteIndex(athletes) {
        const byFull = new Map();
        const byFirst = new Map();
        const byLast = new Map();
        const byToken = new Map();

        const addToMap = (map, key, candidate) => {
          if (!key) {
            return;
          }
          if (!map.has(key)) {
            map.set(key, []);
          }
          map.get(key).push(candidate);
        };

        const uniqueTokens = (values) => {
          const seen = new Set();
          values.forEach((token) => {
            if (token) {
              seen.add(token);
            }
          });
          return Array.from(seen);
        };

        const candidates = athletes.map((athlete) => {
          const nameTokens = tokenize(athlete.name || '');
          const firstTokens = tokenize(athlete.firstName || '');
          const lastTokens = tokenize(athlete.lastName || '');
          const tokens = uniqueTokens([...nameTokens, ...firstTokens, ...lastTokens]);

          return {
            athlete,
            normalisedFull: normaliseName(athlete.name || `${athlete.firstName || ''} ${athlete.lastName || ''}`),
            firstToken: firstTokens[0] || '',
            lastToken: lastTokens[lastTokens.length - 1] || '',
            tokens
          };
        });

        candidates.forEach((candidate) => {
          addToMap(byFull, candidate.normalisedFull, candidate);
          addToMap(byFirst, candidate.firstToken, candidate);
          addToMap(byLast, candidate.lastToken, candidate);
          candidate.tokens.forEach((token) => addToMap(byToken, token, candidate));
        });

        return { byFull, byFirst, byLast, byToken };
      }

      function findUniqueCandidate(candidates, usedIds) {
        if (!Array.isArray(candidates)) {
          return null;
        }

        const available = candidates.filter((candidate) => !usedIds.has(candidate.athlete.athleteId));
        return available.length === 1 ? available[0] : null;
      }

      function intersectCandidateLists(lists, usedIds) {
        const filtered = lists
          .filter((list) => Array.isArray(list) && list.length)
          .map((list) => list.filter((candidate) => !usedIds.has(candidate.athlete.athleteId)));

        if (filtered.length === 0) {
          return [];
        }

        return filtered.reduce((acc, list) =>
          acc.filter((candidate) => list.some((item) => item.athlete.athleteId === candidate.athlete.athleteId))
        );
      }

      function tokenSimilarity(memberToken, candidateToken) {
        if (memberToken === candidateToken) {
          return 2; // exact match
        }

        if (memberToken.length >= 3 && candidateToken.length >= 3) {
          if (candidateToken.startsWith(memberToken) || memberToken.startsWith(candidateToken)) {
            return 1; // prefix / abbreviation match
          }
        }

        return 0;
      }

      function scoreCandidate(candidate, memberTokens) {
        if (!Array.isArray(memberTokens) || memberTokens.length === 0) {
          return { score: 0, exactMatches: 0, prefixMatches: 0, coversAll: false };
        }

        let exactMatches = 0;
        let prefixMatches = 0;

        memberTokens.forEach((token) => {
          const bestMatch = candidate.tokens.reduce((best, candidateToken) => {
            const score = tokenSimilarity(token, candidateToken);
            return score > best ? score : best;
          }, 0);

          if (bestMatch === 2) {
            exactMatches += 1;
          } else if (bestMatch === 1) {
            prefixMatches += 1;
          }
        });

        const matchedTokens = exactMatches + prefixMatches;
        const coversAll = matchedTokens === memberTokens.length && memberTokens.length > 0;
        const score = exactMatches * 3 + prefixMatches + (coversAll ? 1 : 0);

        return { score, exactMatches, prefixMatches, coversAll };
      }

      function chooseBestCandidate(candidates, memberTokens) {
        const scored = candidates
          .map((candidate) => ({ candidate, ...scoreCandidate(candidate, memberTokens) }))
          .filter((entry) => entry.score > 0);

        if (scored.length === 0) {
          return null;
        }

        const coverAll = scored.filter((entry) => entry.coversAll);
        const pool = coverAll.length ? coverAll : scored;
        const bestScore = Math.max(...pool.map((entry) => entry.score));
        const top = pool.filter((entry) => entry.score === bestScore);

        if (top.length === 1) {
          return top[0].candidate;
        }

        // prefer the one with more exact matches when there's a tie
        const bestExact = Math.max(...top.map((entry) => entry.exactMatches));
        const exactWinners = top.filter((entry) => entry.exactMatches === bestExact);

        return exactWinners.length === 1 ? exactWinners[0].candidate : null;
      }

      function gatherTokenCandidates(tokens, index, usedIds) {
        const set = new Map();

        tokens.forEach((token) => {
          const candidates = index.byToken.get(token);
          if (!Array.isArray(candidates)) {
            return;
          }

          candidates.forEach((candidate) => {
            const athleteId = candidate.athlete.athleteId;
            if (usedIds.has(athleteId)) {
              return;
            }
            if (!set.has(athleteId)) {
              set.set(athleteId, candidate);
            }
          });
        });

        return Array.from(set.values());
      }

      function matchAthlete(memberName, index, usedIds) {
        const normalisedFull = normaliseName(memberName);
        const tokens = tokenize(memberName);
        const firstToken = tokens[0] || '';
        const lastToken = tokens.length > 1 ? tokens[tokens.length - 1] : '';

        const fullMatch = findUniqueCandidate(index.byFull.get(normalisedFull), usedIds);
        if (fullMatch) {
          return fullMatch.athlete;
        }

        const intersection = intersectCandidateLists(
          [
            firstToken ? index.byFirst.get(firstToken) : null,
            lastToken ? index.byLast.get(lastToken) : null
          ],
          usedIds
        );

        if (intersection.length === 1) {
          return intersection[0].athlete;
        }

        const tokenCandidates = gatherTokenCandidates(tokens, index, usedIds);
        const bestTokenCandidate = chooseBestCandidate(tokenCandidates, tokens);
        if (bestTokenCandidate) {
          return bestTokenCandidate.athlete;
        }

        const firstMatch = findUniqueCandidate(index.byFirst.get(firstToken), usedIds);
        if (firstMatch) {
          return firstMatch.athlete;
        }

        if (lastToken) {
          const lastMatch = findUniqueCandidate(index.byLast.get(lastToken), usedIds);
          if (lastMatch) {
            return lastMatch.athlete;
          }
        }

        return null;
      }

      function buildTeamStats(teams, athletes) {
        const index = buildAthleteIndex(athletes);
        const usedIds = new Set();

        return teams.map((team) => {
          const members = team.members.map((memberName) => {
            const athlete = matchAthlete(memberName, index, usedIds);

            if (athlete) {
              usedIds.add(athlete.athleteId);
            }

            return {
              memberName,
              athlete,
              displayName: athlete ? athlete.name : `${memberName} (NR)`
            };
          });

          const totalDistance = members.reduce((sum, member) => {
            if (!member.athlete) {
              return sum;
            }
            return sum + (member.athlete.distance_km || 0);
          }, 0);

          return {
            name: team.name,
            members,
            totalDistance
          };
        });
      }

      function renderGlobalLeaderboard(container, teams) {
        if (teams.length === 0) {
          container.innerHTML = '';
          return;
        }

        const sorted = [...teams].sort((a, b) => b.totalDistance - a.totalDistance);

        container.innerHTML = `
          <h2>Global Team Standings</h2>
          <table class="leaderboard-table">
            <thead>
              <tr>
                <th>Team</th>
                <th>Total Distance (km)</th>
              </tr>
            </thead>
            <tbody>
              ${sorted
                .map(
                  (team) => `
                    <tr>
                      <td>${team.name}</td>
                      <td>${team.totalDistance.toFixed(2)}</td>
                    </tr>
                  `
                )
                .join('')}
            </tbody>
          </table>
        `;
      }

      function renderTeams(container, teams) {
        container.innerHTML = teams
          .map((team) => `
            <article class="team-card">
              <h3>${team.name}</h3>
              <table class="leaderboard-table">
                <thead>
                  <tr>
                    <th>Name</th>
                    <th>Distance (km)</th>
                    <th>Avg Speed (km/h)</th>
                  </tr>
                </thead>
                <tbody>
                  ${team.members
                    .map((member) => {
                      if (!member.athlete) {
                        return `
                          <tr>
                            <td>${member.displayName}</td>
                            <td>--</td>
                            <td>--</td>
                          </tr>
                        `;
                      }

                      return `
                        <tr>
                          <td>${member.displayName}</td>
                          <td>${member.athlete.distance_km.toFixed(2)}</td>
                          <td>${member.athlete.avg_speed_kmh.toFixed(2)}</td>
                        </tr>
                      `;
                    })
                    .join('')}
                </tbody>
              </table>
            </article>
          `)
          .join('');
      }

      async function fetchJson(url) {
        const response = await fetch(url);
        if (!response.ok) {
          throw new Error(`Request failed with status ${response.status}`);
        }
        return response.json();
      }

      async function loadLeaderboards() {
        const status = document.getElementById('status');
        const eventWindow = document.getElementById('event-window');
        const globalContainer = document.getElementById('global-leaderboard');
        const teamsContainer = document.getElementById('teams-container');

        eventWindow.textContent = '';
        try {
          const [activitiesPayload, teamsPayload] = await Promise.all([
            fetchJson('/api/club/activities'),
            fetchJson('/api/teams')
          ]);

          const athletes = activitiesPayload.activities || [];
          const teams = teamsPayload.teams || [];

          eventWindow.textContent = buildEventWindowLabel(activitiesPayload.event);

          if (teams.length === 0) {
            status.textContent = 'No teams configured yet.';
            globalContainer.innerHTML = '';
            teamsContainer.innerHTML = '';
            return;
          }

          const teamsWithStats = buildTeamStats(teams, athletes);

          if (athletes.length === 0) {
            status.textContent = 'No walk or run activities found.';
          } else {
            status.textContent = '';
          }

          renderGlobalLeaderboard(globalContainer, teamsWithStats);
          renderTeams(teamsContainer, teamsWithStats);
        } catch (error) {
          console.error(error);
          status.textContent = 'Could not load leaderboard data. Please try again later.';
          eventWindow.textContent = '';
        }
      }

      loadLeaderboards();
    </script>
  </body>
</html>
